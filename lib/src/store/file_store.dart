import 'dart:async';
import 'dart:developer';
import 'package:universal_io/io.dart';
import 'store_interface.dart';
import 'package:path/path.dart' as path;

/// [TusFileStore] is used for storing upload progress locally on the device.
/// It is used by [TusClient] to resume uploads at correct %.
class TusFileStore implements TusStore {
  /// It must receive the directory to store the upload.
  TusFileStore(this.directory, {bool debug = false}) : _debug = debug;

  /// The directory where the upload is stored.
  final Directory directory;
  
  /// Debug flag to enable verbose logging
  bool _debug = false;
  
  /// Internal logging method that respects the debug flag
  void _log(String message) {
    if (_debug) {
      log('[TusFileStore] $message');
    }
  }
  
  @override
  void setDebug(bool value) {
    _debug = value;
    _log('Debug logging ${value ? 'enabled' : 'disabled'}');
  }
  
  @override
  bool isDebugEnabled() {
    return _debug;
  }

  /// Store a new [fingerprint] and its upload [url]. The [fingerprint] is
  /// generated by [TusClient] and is used to identify the upload.
  @override
  Future<void> set(String fingerprint, Uri url) async {
    _log('Storing URL for fingerprint: $fingerprint');
    _log('URL: $url');
    
    final file = await _getFile(fingerprint);
    _log('File path for storage: ${file.path}');
    
    await file.writeAsString(url.toString());
    _log('URL stored successfully');
  }

  /// Retrieve an upload's Uri for a [fingerprint].
  /// If no matching entry is found this method will return `null`.
  @override
  Future<Uri?> get(String fingerprint) async {
    _log('Getting URL for fingerprint: $fingerprint');
    
    final file = await _getFile(fingerprint);
    _log('Looking for file: ${file.path}');
    
    if (file.existsSync()) {
      final urlString = await file.readAsString();
      _log('Found URL: $urlString');
      return Uri.parse(urlString);
    }
    
    _log('No file found for fingerprint');
    return null;
  }

  /// Remove an entry from the store using an upload's [fingerprint].
  @override
  Future<void> remove(String fingerprint) async {
    _log('Removing entry for fingerprint: $fingerprint');
    
    final file = await _getFile(fingerprint);
    _log('File path to remove: ${file.path}');

    if (file.existsSync()) {
      _log('File exists, deleting');
      file.deleteSync();
    } else {
      _log('File does not exist, nothing to delete');
    }

    // Check if directory exists before trying to delete it
    if (directory.existsSync()) {
      try {
        _log('Checking if directory is empty');
        final contents = directory.listSync();
        if (contents.isEmpty) {
          _log('Directory is empty, deleting directory');
          directory.deleteSync(recursive: true);
        } else {
          _log('Directory not empty, keeping directory');
        }
      } catch (e) {
        _log('Error checking directory: $e');
      }
    } else {
      _log('Directory does not exist, nothing to clean up');
    }
  }

  Future<File> _getFile(String fingerprint) async {
    _log('Creating file path for fingerprint: $fingerprint');
    
    // Create directory if it doesn't exist
    if (!directory.existsSync()) {
      _log('Directory does not exist, creating: ${directory.path}');
      await directory.create(recursive: true);
    } else {
      _log('Directory already exists: ${directory.path}');
    }
    
    // Use path.join for proper path construction
    final filePath = path.join(directory.absolute.path, fingerprint);
    _log('Final file path: $filePath');
    
    return File(filePath);
  }
}